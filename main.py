import cv2 as cv
import numpy as np
from fastapi import FastAPI, Response, UploadFile

app = FastAPI()


# Função para calcular a distância entre dois pontos
def distancia(pt1, pt2):
    return np.sqrt((pt1[0] - pt2[0]) ** 2 + (pt1[1] - pt2[1]) ** 2)

# TODO: Como posso colocar n templates?
# TODO: Incluir o modelo treinado.

@app.post(
    "/find_boxes/",  # Set what the media type will be in the autogenerated OpenAPI specification.
    # fastapi.tiangolo.com/advanced/additional-responses/#additional-media-types-for-the-main-response
    responses={200: {"content": {"image/png": {}}}},
    # Prevent FastAPI from adding "application/json" as an additional
    # response media type in the autogenerated OpenAPI specification.
    # https://github.com/tiangolo/fastapi/issues/3258
    response_class=Response,
)
async def find_boxes(test_image: UploadFile, box_image: UploadFile):
    test_img_contents = await test_image.read()
    box_img_contents = await box_image.read()
    test_img_arr = np.fromstring(test_img_contents, np.uint8)
    box_image_arr = np.fromstring(box_img_contents, np.uint8)
    img_rgb = cv.imdecode(test_img_arr, cv.IMREAD_COLOR)
    assert img_rgb is not None, "file could not be read, check with os.path.exists()"
    template = cv.imdecode(box_image_arr, cv.IMREAD_GRAYSCALE)
    assert template is not None, "file could not be read, check with os.path.exists()"
    w, h = template.shape[::-1]

    img_gray = cv.cvtColor(img_rgb, cv.COLOR_BGR2GRAY)
    res = cv.matchTemplate(img_gray, template, cv.TM_CCOEFF_NORMED)
    threshold = 0.5
    loc = np.where(res >= threshold)
    # Lista para armazenar pontos já processados
    pontos_processados = []
    i = 0
    qa = {}
    question = 1
    qa[question] = []

    opcoes_por_pergunta = 3
    # Processar cada ponto encontrado
    for pt in zip(*loc[::-1]):
        # Verificar se o ponto está muito próximo de algum ponto já processado
        if all(distancia(pt, p) > 100 for p in pontos_processados):  # Limiar de distância = 10 pixels
            pontos_processados.append(pt)
            # Crop da imagem
            qa[question] += [pt]  # [img_rgb[pt[1] : pt[1] + h, pt[0] : pt[0] + w]]
            if len(qa[question]) == opcoes_por_pergunta:
                question += 1
                qa[question] = []
            cv.rectangle(img_rgb, pt, (pt[0] + w, pt[1] + h), (0, 0, 255), 2)
            i += 1

    _, encoded_img = cv.imencode('.PNG', img_rgb)
    return Response(content=encoded_img.tostring(), media_type="image/png")
